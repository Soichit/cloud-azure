[Hosted on Azure] (http://soichicloud.cloudapp.net/)


The first step was setting up Azure. I created a Web Application on Microsoft Azure, which I later changed to a Cloud Application so the performance counter worked when I deployed. I also created an Azure storage account where I created a blob storage container to dump my wikipedia title data. I downloaded the wikipedia titles file and I created a gulp script to preprocess the file to remove any letters that weren’t in the regular alphabet. Once preprocessed, I uploaded the file into the blob so I can access it later in my WebService1.asmx.

To create the trie data structure, I create a TrieNode class and a Trie class. My TrieNode contained 2 fields initially: a dictionary Dict that held characters to other TrieNodes, and a boolean EndOfWord, that determined whether the nodes spelled out a complete word (later I added a list HyrbidList of strings for the hybrid list extra credit). To encapsulate, I made the set methods private and only accessible with public methods. Then I created my Trie class with 2 main methods: insert and search. When inserting a word, I iterated through each character and passed it on to child nodes iteratively, creating a new node for the character if it wasn’t already there. When searching for 10 suggestions, I first searched the prefix to traverse the nodes  to spell out the word, then I searched for the remaining suggestions recursively rooted from the same node path as the input passed in. The base case was if I found 10 suggestions, and to do a depth-first-search, I did a foreach loop to iterate through the dictionary of characters to TrieNodes.

Then, I worked on my WebService1.asmx to create an object from the Trie class and I made it static so the Trie can be used through different methods. I had 3 main methods: downloadWiki, buildTrie, and searchTrie. The downloadWiki method connected to my Azure storage account and got the preprocessed wikipedia file from the blob storage earlier. I then downloaded the file locally for my buildTrie method to use. My buildTrie method used a StreamReader to read each line of the wikipedia file and used a performance-counter to check the system memory every 1000 lines and stopped when the memory went below 20mb. searchTrie is passed in the user input from the front-end and returns a list of 10 suggestions from that prefix. I had to serialize the code to return the list in JSON format.

The final step was to create an index.html search input and connect that with my back-end code using AJAX call with jQuery. I had a keyup event-listener and every time the user typed in something, it would trim and turn the user input into lower case and convert spaces into underscores. I did an AJAX call to the SearchTrie method from WebService1 and appended my result into a div dropdown.



I attempted 25 points of extra credit.
[10pts] Hybrid List & Trie data structure (convert to Trie after > X entries in node)
[10pts] Handle misspelling gracefully**
[5pts] Query suggestion based on user searches

Hybrid List:
The Hybrid List stores a list of strings within each node instead of just the dictionary of characters. This way, there is less nodes used so it saves space and to see this in my web service, you can see suggestions from a~z. How I implemented this was by creating an extra field in my TrieNode which was a list of strings, HybridList. Within my Trie, I created a global variable, hybridCapacity, which was set to 20 so each node would only rearrange itself when it hit the capacity of 20. I had to change my insert method to be recursive instead of iterative, and the base case was if the hybrid capacity was not reached in the current node, I would return a string “done”. If the capacity is reached, I had  a foreach loop to iterate through all the words in the hybrid list and rearrange them passing it down to its children node. If there wasn’t a node for the first character of that word, I would create a new TrieNode, else I would pass that word into the node that matches the character. Some edge cases I accounted for were if the node was 1 character long, then I set the endOfWord to true not with the current node but the children node I passed in recursively. Also I would only recurse through this when the word in the hybrid list had at least 2 characters. Outside the foreach loop, I cleared the HybridList, doing so anywhere else in my code cleared the hybridlist too early before it could be passed in.

The search suggestions method was also very hard to implement because there were so many edge cases when searching for a possible prefix. The first part of this, searching for possible suggestions within the prefix was harder because I had to check the hybrid list of each node I traversed through. When checking the hybrid list, I had to subtract the user input from the tempWord already built from traversing the nodes and check if any word in the hybrid list started from that subtracted word. If it did match, I would add it to my list of results and return when I found 10 results. If I don’t find 10 suggestions just by traversing through the prefix, I would send the data to the recursive method searchSuggestions, which would traverse through the entire tree using depth-first search, and then iterating through the hybrid list of each node afterwards. Initially I checked the hybrid list first, and the ordering of the suggestions was not returned in inserted order so I reordered my code. I checked for duplicate lines, and then I returned my result when I hit 10 results or iterated through the entire Trie.


Handling misspelling gracefully
Code for Levenshtein function: https://www.dotnetperls.com/levenshtein

To see this in my web service, you can try misspelling words, like “applez”, and it would return similar results within a levenshtein distance of 2. The way I implemented this, it would only check for misspelled words if I search through my suggestions regularly, and it returns less than 10 results. Only when the results returned are less than 10, I run my recursive searchMistakes function. I pass in a node that I want to start searching from and then I go through every node in the dictionary with depth-first search, and then I will check each word in the hybrid list. When checking each word, I will pass it into the levenshtein function I found online and check if the distance is less than the global distance I set, for my case it’s 2. 

After implementing my code the first time, I realized that returning the results for misspellings took 5 seconds. To improve performance, instead of passing in root into my searchMistakes function, I traversed through the first 2 nodes of the passed in input with a new function, traverseTrie. So if the user entered, “APPLEZ”, I would traverse through “AP” and start searching the entire trie from there. In doing so, my algorithm does not account for all possible words that are within a levenshtein distance of 1, because the first 2 would be the same 2 letters that I hardcoded, but I was able to improve performance to under 0.5 milliseconds. This was a design decision that I made because I believed performance was more important than the unlikely chance that the user spells the first 2 letters incorrectly.


Query suggestion based on user searches:
To do so, I created a static dictionary variable of word to count within my Trie class. I added a button in my index.html and any time the user saves the query, the front-end would do an AJAX call similar to the keyup one but  it would increment the input passed in. Then I would pass the dictionary back to the front-end so it can append the suggestion and count within the dropdown. Finally I used a quick function to sort my dictionary so the ones with more counts are displayed first. I accounted for the case when the user tries to input a word that's misspelled and doesn't exist in the trie.
